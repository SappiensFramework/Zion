<?php/** * *    Sappiens Framework *    Copyright (C) 2014, BRA Consultoria * *    Website do autor: www.braconsultoria.com.br/sappiens *    Email do autor: sappiens@braconsultoria.com.br * *    Website do projeto, equipe e documentação: www.sappiens.com.br *    *    Este programa é software livre; você pode redistribuí-lo e/ou *    modificá-lo sob os termos da Licença Pública Geral GNU, conforme *    publicada pela Free Software Foundation, versão 2. * *    Este programa é distribuído na expectativa de ser útil, mas SEM *    QUALQUER GARANTIA; sem mesmo a garantia implícita de *    COMERCIALIZAÇÃO ou de ADEQUAÇÃO A QUALQUER PROPÓSITO EM *    PARTICULAR. Consulte a Licença Pública Geral GNU para obter mais *    detalhes. *  *    Você deve ter recebido uma cópia da Licença Pública Geral GNU *    junto com este programa; se não, escreva para a Free Software *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA *    02111-1307, USA. * *    Cópias da licença disponíveis em /Sappiens/_doc/licenca * *//** * @author Pablo Vanni - pablovanni@gmail.com * @since 23/02/2005 * Atualizada Por: Pablo Vanni - pablovanni@gmail.com<br> * Última Atualização: 26/01/2015 * Atualizada Por: Feliphe "O Retaliador" Bueno - feliphezion@gmail.com * @name  Paginação de resultado para uma consulta no banco de dados * @version 2.0 * @package Framework */namespace Zion\Paginacao;use Zion\Paginacao\PaginacaoVO;use Zion\Banco\Conexao;class Paginacao extends PaginacaoVO{    private $con;    /**     * Paginacao::__construct()     *      * @return     */    public function __construct($con = NULL)    {        parent::__construct();        if (!$con) {            $this->con = Conexao::conectar();        } else {            $this->con = $con;        }    }    /**     * 	Retorna um ResultSet com um numero determinado de QLinhas     * 	@param QLinhas Inteiro - Número de QLinhas a retotnar no RS     * 	@param Sql String - Query SQL que irá selecionar os dados     * 	@param PaginaAtual Inteiro - Página atual dos QLinhas     * 	@param Chave Inteiro - Campo Chave pelo qual deve ser ordenado os resultados     * 	@param QuemOrdena Inteiro - Número de QLinhas a retotnar no RS     * 	@param TipoOrdenacao String - Número de QLinhas a retotnar no RS     * 	@param Ordena String - Número de QLinhas a retotnar no RS     * 	@return ResultSet     */    public function rsPaginado()    {        $qLinhas = parent::getQLinhas();        $sql = parent::getSql();        $paginaAtual = parent::getPaginaAtual();        $chave = parent::getChave();        $aliases = parent::getAliasOrdena();        $aliasOrdena = (\is_array($aliases) ? $aliases[$chave] . '.' : (empty($aliases) ? NULL : $aliases . '.'));        $quemOrdena = parent::getQuemOrdena();        $limitAtivo = parent::getLimitAtivo();        //Extremo dos Proximos QLinhas        $inicio = ($paginaAtual == 1) ? 0 : (($paginaAtual * $qLinhas) - $qLinhas);        //Verifica Ordenção        if (!empty($quemOrdena)) {            $aliasOrdena = ((\is_array($aliases) and isset($aliases[$quemOrdena])) ? $aliases[$quemOrdena] . '.' : NULL);            if (\is_string($sql)) {                $ordem = " ORDER BY " . $aliasOrdena . $quemOrdena . " " . parent::getTipoOrdenacao();            } else {                $sql->orderBy($aliasOrdena . $quemOrdena, parent::getTipoOrdenacao());            }        } else {            if (\is_string($sql)) {                $ordem = " ORDER BY " . $aliasOrdena . $chave . " " . parent::getTipoOrdenacao();            } else {                $sql->orderBy($aliasOrdena . $chave, parent::getTipoOrdenacao());            }        }        //Não é Paginado        if ($qLinhas == 0) {            if (\is_string($sql)) {                return $this->con->executar($sql . " " . $ordem);            } else {                return $sql->execute();            }        }        //Definir Limit        $limit = '';        if ($limitAtivo and $qLinhas <> 0) {            if (\is_string($sql)) {                $limit = ($qLinhas <> 0) ? " LIMIT " . $inicio . "," . $qLinhas : "";            } else {                $sql->setFirstResult($inicio);                $sql->setMaxResults($qLinhas);            }        }        //Retorno        if (\is_string($sql)) {            $rS = $this->con->executar($sql . $ordem . $limit);        } else {            $rS = $sql->execute();        }        return $rS;    }    /**     * 	Retorna um ResultSet com um numero determinado de QLinhas     * 	@param QLinhas Inteiro - Número de QLinhas a retotnar no RS     * 	@param Sql String - Query SQL que irá selecionar os dados     * 	@param PaginaAtual Inteiro - Página atual dos QLinhas     * 	@param IrParaPagina Booleano - Ir diretamente para a página desejada habilitar ou não esta opação na paginação     * 	@return Booleano     */    public function listaResultados()    {        $buffer = [];                $qLinhas = parent::getQLinhas();        $paginaAtual = parent::getPaginaAtual();        $quemOrdena = parent::getQuemOrdena();        $metodoFiltra = parent::getMetodoFiltra();        $sql = parent::getSql();        $processarNumeroPaginas = parent::getProcessarNumeroPaginas();        if ($qLinhas === 0) {            return;        }                if (\is_string($sql)) {            if (\substr_count(\strtoupper(parent::getSql()), 'SELECT ') > 1) {                $numLinhas = $this->con->execNLinhas(parent::getSql());            } else {                $numLinhas = $this->con->execRLinha($this->converteSql(parent::getSql()));            }        } else {            if ($processarNumeroPaginas === false) {                $inicio = ($paginaAtual == 1) ? 1 : (($paginaAtual * $qLinhas) - $qLinhas);                $sql->setFirstResult($inicio);                $sql->setMaxResults((($qLinhas + 1) + ($paginaAtual * $qLinhas - $qLinhas)));                $numLinhas = $this->con->execNLinhas($sql);            } else {                $sql->add("select", 'COUNT(*) AS TotalRegistrosPag', true)                        ->setFirstResult(0);                $numLinhas = $this->con->execRLinha($sql, "TotalRegistrosPag");            }        }        //Total de Páginas        if ($processarNumeroPaginas === false) {            $totalPaginas = \ceil($numLinhas / $qLinhas) + $paginaAtual - 1;        } else {            $totalPaginas = \ceil($numLinhas / $qLinhas);        }                $buffer['paginaAtual']          = $paginaAtual;        $buffer['totalPaginas']         = $totalPaginas;        $buffer['totalRegistros']       = $numLinhas;        $buffer['totalRegistrosPagina'] = $qLinhas;        //$final = $totalPaginas <= 1 ? $numLinhas : $qLinhas;        //Imprimindo QLinhas        if ($totalPaginas > 1) {            //Verifica se existe variavel para QuemOrdena de ordenação            if (!empty($quemOrdena)) {                Parametros::setParametros("Full", array("qo" => $quemOrdena));            }            //Anterior            if ($paginaAtual > 1) {                Parametros::setParametros("Full", array("pa" => ($paginaAtual - 1)));                $onclick = $metodoFiltra . '(\'' . Parametros::getQueryString() . '\'); sisSpa(\'' . ($paginaAtual - 1) . '\');';                $buffer['anterior']['onclick'] = $onclick;                $buffer['anterior']['ativo'] = true;                            } else {                $buffer['anterior']['ativo'] = false;                            }            //Proxima            if ($paginaAtual < $totalPaginas) {                Parametros::setParametros("Full", array("pa" => ($paginaAtual + 1)));                $onclick = $metodoFiltra . '(\'' . Parametros::getQueryString() . '\'); sisSpa(\'' . ($paginaAtual + 1) . '\');';                $buffer['proximo']['onclick'] = $onclick;                $buffer['proximo']['ativo'] = true;                            } else {                $buffer['proximo']['ativo'] = false;                            }        }                return $buffer;    }    /**     * Paginacao::converteSql()     *      * @return     */    public function converteSql($sql)    {        return \preg_replace('/SELECT.*FROM/i', 'SELECT COUNT(*) as Total FROM ', \preg_replace('/\s/i', ' ', $sql));    }}